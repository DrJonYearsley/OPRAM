# OPRAM_processing_functions.jl
# Functions for processing the results from degree day models 
# once the basic results have been generated by OPRAM_main_program

# function extract_results(doy::Int32, result::DataFrame)
# function create_doy_results(dates::Vector{Date}, adult_emerge::DataFrame)
# function dist_create_doy_results_deprecated(dates::Vector{Date}, adult_emerge::DataFrame)
# function aggregate_to_hectad_deprecated(result_1km::DataFrame, grid::DataFrame)
# function aggregate_to_hectad(df_1km::DataFrame)

#
# Jon Yearsley (jon.yearsley@ucd.ie)
# 2nd June 2025
#
# Functions checked by JY: 30th Oct 2025
# ====================================================================



# =========================================================
# ============= Defne functions ===========================




function extract_results(doy::Int32, result::DataFrame)
  # Function to calculate number of generations per year, and first
  # day of adult emergence based on a starting development on doy
  #
  #  If development doesn't complete by the end of the simulation (usually 4 years)
  #  then the emergeDOY is set to missing and nGenerations is set to 0
  #
  #  Arguments:
  #      doy         day of year when larval development begins
  #      result      data frame containing the results from the model
  #  
  #  Output:
  #   a data frame with the following columns:
  #       ID            unique ID for each spatial location   
  #       startDOY      day of year to start development     
  #       nGenerations  the number of generations within the year
  #       emergeDOY     adult emergence day of year 
  #
  # Checked JY: 30th Oct 2025
  ########################################################################

  # Find start and end indicies for each location
  idx1 = indexin(unique(result.ID), result.ID)
  idx2 = vcat(idx1[2:end] .- 1, length(result.ID))


  # Create data frame to hold results
  out_res = DataFrame(ID=result.ID[idx1],
    startDOY=doy,
    nGenerations=0.0,      # Must be Float because it can be fractional 
    emergeDOY=Vector{Union{Missing,Int32}}(missing, length(idx1)))


  # Set up starting DOY for each location
  startDOY = zeros(Union{Missing,Int32}, length(idx1)) .+ doy  # Start DOY for each location
  first_pass = true                                            # True for the first generation

  # Set startDOY to zero for a location if no more generations can be completed in the year
  # when all startDOY are zero then stop
  while any(startDOY .> 0)
    # Find index of result output that corresponds to desired day of year (ie doy>=result.DOY)
    # this assumes results are ordered by DOY for each location
    idx3 = [searchsortedfirst(result.DOY[idx1[i]:idx2[i]], startDOY[i]) - 1 + idx1[i] for i in eachindex(idx1)]

    # Find out if end of current developmental generation occurs before maxYears (i.e. occurs before data on next location)
    # idx2[i] is the last index for the present location
    # idx2[i]+1 is the first index of the next location   = idx1[i+1]
    development_complete = startDOY .> 0 .&& idx2 .+ 1 .> idx3

    # Find out if development happens within the first year (i.e. 365 days so leap years are ignored)
    if (idx3[end] == nrow(result) + 1)
      # If final idx3 gives no developement (i.e. idx3[end] is nrow+1) then 
      # set its within_a_year to false

      # Is the generation complete within the year?
      within_a_year = result.emergeDOY[idx3[1:end-1]] .<= 365   

      # Add a single false for the last index (because idx3[end] == nrow(result) + 1)
      push!(within_a_year, false)                      
    else
      # Work out all values of within_a_year
      # Is the generation complete within the year?
      within_a_year = result.emergeDOY[idx3] .<= 365
    end

    # Create booleans that will increment generation count
    full_generation = development_complete .& within_a_year
    partial_generation = development_complete .& .!within_a_year

    # Add on one for a full generation
    out_res.nGenerations[full_generation] .+= 1

    # Calculate end of year fraction of time towards next generation
    out_res.nGenerations[partial_generation] .+= (365 .- startDOY[partial_generation]) ./
                                                 (result.emergeDOY[idx3[partial_generation]] - startDOY[partial_generation])

    # If this is the first time through the loop, record the emergance day
    if first_pass
      # Only update adult emergence DOY if emergence is complete (but could take multiple years)   
      out_res.emergeDOY[development_complete] .= result.emergeDOY[idx3[development_complete]]
      first_pass = false
    end

    # Reset starting DOY to zero
    startDOY = zeros(Int32, length(idx1))

    # If a full generation completed within the year, update starting doy to be the
    # day after generation completed
    startDOY[full_generation] .= result.emergeDOY[idx3[full_generation]] .+ 1

    # Remove startDOY >= 365 by setting it equal to 0
    # This step shouldn't be needed, but just to make sure we do it anyway
    startDOY[startDOY.>=365] .= 0
  end

  # Set nGenerations to zero if no emergence occurs within the simulation
  out_res.nGenerations[ismissing.(out_res.emergeDOY)] .= 0.0

  return (out_res)
end





# ------------------------------------------------------------------------------------------




function create_doy_results(dates::Vector{Date}, adult_emerge::DataFrame, grid::DataFrame)
  # Function to calculate number of generations per year, and first
  # day of adult emergence for specific starting days of year.
  #
  # Note:
  #   If emergence day of year exceeds simulation timeframe (maxYears) then 
  #     set emergeDOY to missing and nGenerations to 0
  #   If there is no result for a spatial location then the location is appended to the 
  #     results with emergeDOY set to missing and nGenerations set to 0
  #
  #  Arguments:
  #   dates           a vector of dates when larval development begins
  #   adult_emerge    data frame containing the results from the model
  #   grid            a data frame containing the spatial grid
  #  
  #  Output:
  #   a data frame with the following columns:
  #       ID            unique ID for each spatial location  
  #       startDOY      starting DOY for larval development  
  #       startDate     starting date for larval development  
  #       nGenerations  number of generations in a year    
  #       emergeDOY     adult emergence day of year 
  #
  # Checked JY: 30th Oct 2025
  ########################################################################

  # Initialise dataframe for outputs
  out = DataFrame(ID=Int32[],
    startDOY=Int32[],
    startDate=Date[],
    nGenerations=Vector{Union{Missing,Float64}}(missing, 0),
    emergeDOY=Vector{Union{Missing,Int32}}(missing, 0))


  for d in eachindex(dates)
    # Produce results for a specific DOY
    result = extract_results(convert(Int32, dayofyear(dates[d])), adult_emerge)

    # Add in a column with starting dates and emergence dates rather than DOY 
    # (dates handle leap years when dealing with starting dates specified using months)
    result.startDate .= dates[d]

    # Find spatial locations with no output and add them to the result as missing
    # (these are locations where no emergence occurs within the simulation time frame)
    missingIDs = setdiff(grid.ID, result.ID)
    if !isempty(missingIDs)
      append!(result,
        DataFrame(ID=missingIDs,
          startDOY=convert(Int32, dayofyear(dates[d])),
          startDate=dates[d],
          nGenerations=0.0,
          emergeDOY=missing))
    end

    #=  Remove this block because date is no longer returned by the function
    # Initialise column with missing values
    result.emergeDate = Vector{Union{Missing,Date}}(missing, length(result.ID))

    # Find results with a non-zero emergence DOY
    idx = .!ismissing.(result.emergeDOY)
    # Calculate date of emergence from day of year
    result.emergeDate[idx] = Date(year(dates[d])) .+ Day.(result.emergeDOY[idx] .- 1)
    =#


    # Add these results to the other outputs
    append!(out, result)
  end

  return out
end




# ------------------------------------------------------------------------------------------




function dist_create_doy_results_deprecated(dates::Vector{Date}, adult_emerge::DataFrame)
  # Deprecated
  # This function is intended to be used for parallel calculations, but there is no 
  # time saving compared to the create_doy_results() function
  #
  # Function to calculate number of generations per year, and first
  # day of adult emergence for specific starting days of year.
  #
  # If emergence date exceeds simulation timeframe (maxYears) then set to missing
  #
  #  Arguments:
  #   dates           a vector of dates when larval development begins
  #   adult_emerge    data frame containing the results from the model
  #  
  #  Output:
  #   a data frame with the following columns:
  #       ID            unique ID for each spatial location  
  #       startDOY      starting DOY for larval development  
  #       startDate     starting date for larval development  
  #       nGenerations  number of generations in a year    
  #       emergeDOY     adult emergence day of year 
  #       emergeDate    adult emergence date 
  ########################################################################

  out = DataFrame()    # Initialise dataframe for outputs


  for d in eachindex(dates)
    # Produce results for a specific DOY
    result = extract_results(convert(Int32, dayofyear(dates[d])), adult_emerge)

    # Add in a column with starting dates and emergence dates rather than DOY
    result.startDate .= dates[d]

    # Initialise column with missing values
    result.emergeDate = Vector{Union{Missing,Date}}(missing, length(result.ID))

    # Find results with a non-zero emergence DOY
    idx = .!ismissing.(result.emergeDOY)
    # Calculate date of emergence from day of year
    result.emergeDate[idx] = Date(year(dates[d])) .+ Day.(result.emergeDOY[idx] .- 1)

    # Add these results to the other outputs
    append!(out, result)
  end

  return out
end




# ------------------------------------------------------------------------------------------




function aggregate_to_hectad_deprecated(result_1km::DataFrame, grid::DataFrame)
  # Deprecated
  # Function to take results on a 1km grid an aggregate them to a 10km grid
  #
  # Arguments:
  #   grid              information about the spatial grid
  #   result_1km        results from the model on 1km grid
  #  
  #  Output:
  #   a data frame with the following columns:
  #       hectad            unique hectad grid reference
  #       east              easting of bottom left of hectad
  #       north             northing of bottom left of hectad
  #       startDOY          starting DOY for larval development  
  #       startDate         starting date for larval development  
  #       nGenerations_max  maximum number of generations in a year in hectad
  #       emergeDOY_min     minimum adult emergence day of year in a hectad
  #       emergeDate_min    minimum adult emergence date in a hectad
  ########################################################################

  # Add bottom left eastings and northings of a hectad into result_1km
  eastList = sort(unique(grid.east))
  northList = sort(unique(grid.north))
  result_1km.east_hectad = convert.(Int32, floor.(eastList[result_1km.east_idx] ./ 1e4) .* 1e4)
  result_1km.north_hectad = convert.(Int32, floor.(northList[result_1km.north_idx] ./ 1e4) .* 1e4)

  # Group data frame by location and then starting DOY/Date 
  df_group = groupby(result_1km, [:east_hectad, :north_hectad, :startDOY, :startDate])

  # Calculate worst case results within each hectad for nGenerations and emergeDOY
  # for each starting DOY. 
  # These worst case scenarios are not affected by locations where no emergence occurred
  df_agg = combine(df_group,
    :nGenerations => (x -> quantile(x, 1.0)) => :nGenerations_max,
    :emergeDOY => (x -> quantile(x, 0.0)) => :emergeDOY_min)   # Max generations per hectad and minimum emergence DOY

  # Add in columns with start and emergence dates
  df_agg.emergeDate_min = Vector{Union{Missing,Date}}(missing, nrow(df_agg))
  idx = df_agg.emergeDOY_min .> 0
  df_agg.emergeDate_min[idx] .= Date.(year.(df_agg.startDate[idx])) .+ Day.(floor.(df_agg.emergeDOY_min[idx]))


  # Create a code that corresponds to hectad in the grid data frame
  h_idx = [findfirst(grid.hectad .== h) for h in unique(grid.hectad)]
  h_nGen_idx = [findfirst(df_agg.east_hectad[i] .== floor.(grid.east[h_idx] ./ 1e4) .* 1e4 .&& df_agg.north_hectad[i] .== floor.(grid.north[h_idx] ./ 1e4) .* 1e4) for i in 1:nrow(df_agg)]

  # Add hectad code into both data frames
  insertcols!(df_agg, 1, :hectad => grid.hectad[h_idx[h_nGen_idx]], after=false)


  # Return final dataframe
  return df_agg
end


# ------------------------------------------------------------------------------------------


function aggregate_to_hectad(df_1km::DataFrame)
  # Function to take results on a 1km grid an aggregate them to a 10km grid
  # This is the latest function that is used in OPRAM_calculate_anaomaly.jl
  #
  # The worst case scenario is used for each hectad. 
  # I.e. the earliest emergeDOY and the largest nGenerations
  #
  # Arguments:
  #   df_1km                        results from the model on 1km grid
  #  
  #  Output:
  #   a data frame with the following columns:
  #       hectad                    unique hectad grid reference
  #       east_hectad               easting of bottom left of hectad
  #       north_hectad              northing of bottom left of hectad
  #       startDate                 starting date for larval development  
  #       nGenerations_max          maximum number of generations in a year in the hectad
  #       nGenerations_median_max   maximum across a hectad  of multi year median   
  #       nGenerations_anomaly_median  median anomaly in number of generations in a year in the hectad
  #       emergeDOY_min             minimum across a hectad of adult emergence day of year
  #       emergeDOY_median_min      minimum across a hectad of adult emergence day of year
  #       emergeDOY_anomaly_median  median across a hectad of adult emergence day of year
  #       nMissing                  number of locations with no emergence in the hectad
  #
  # Checked JY: 30th Oct 2025
  ########################################################################

  # Add bottom left eastings and northings of a hectad into df_1km
  df_1km.east_hectad = convert.(Int32, floor.(df_1km.east ./ 1e4) .* 1e4)
  df_1km.north_hectad = convert.(Int32, floor.(df_1km.north ./ 1e4) .* 1e4)


  # Set missing values to be extremes (e.g. generations are small and emergeDOY is large)
  # nGenerations should have no missing data because no emergence corresponds to nGenerations = 0.0

  # Try to find the type of emergeDOY and nGenerations
  # typeidx = findfirst(!isequal(Missing), typeof.(df_1km.emergeDOY))
  missing_DOY = convert(Int32, 99999)

  # typeidx = findfirst(!isequal(Missing), typeof.(df_1km.nGenerations))
  missing_nGenerations = convert(Float64, -99999)

  idx1 = ismissing.(df_1km.emergeDOY)

  if all(idx1)
    df_1km.emergeDOY .= missing_DOY
    df_1km.nGenerations .= missing_nGenerations
  else
  df_1km.emergeDOY[idx1] .= missing_DOY
  df_1km.nGenerations[idx1] .= missing_nGenerations 
  end

  idx2 = ismissing.(df_1km.emergeDOY_median)
  df_1km.emergeDOY_median[idx2] .= missing_DOY
  df_1km.nGenerations_median[idx2] .= missing_nGenerations

  idx3 = ismissing.(df_1km.emergeDOY_anomaly)
  df_1km.emergeDOY_anomaly[idx3] .= missing_DOY
  df_1km.nGenerations_anomaly[idx3] .= -missing_nGenerations


  # Group data frame by location and then starting Date 
  df_group = groupby(df_1km, [:east_hectad, :north_hectad, :startDate])



  # Calculate worst case results within each hectad for nGenerations and emergeDOY
  # for each starting date. 
  df_10km = combine(df_group,  
    :nGenerations => (x -> if sum(.!isa.(x,Missing))>0 quantile(skipmissing(x), 1.0) else missing end)  => :nGenerations_max,       # Max generations per hectad
    :nGenerations_median => (x -> if sum(.!isa.(x,Missing))>0 quantile(skipmissing(x), 1.0) else missing end)  => :nGenerations_median_max,
    :nGenerations_anomaly => (x -> if sum(.!isa.(x,Missing))>0 quantile(skipmissing(x), 0.5) else missing end)  => :nGenerations_anomaly_median,
    :emergeDOY => (x -> if sum(.!isa.(x,Missing))>0 quantile(skipmissing(x), 0.0) else missing end)  => :emergeDOY_min,                         # Min emergence DOY
    :emergeDOY_median => (x -> if sum(.!isa.(x,Missing))>0 quantile(skipmissing(x), 0.0) else missing end)  => :emergeDOY_median_min,
    :emergeDOY_anomaly => (x -> if sum(.!isa.(x,Missing))>0 quantile(skipmissing(x), 0.5) else missing end)  => :emergeDOY_anomaly_median,
    :emergeDOY => (x -> sum(x.==missing_DOY)) => :nMissing  )                            # Count number of no emergence events  

  # Add in missing values for emergeDOY and zero for nGEnerations where 10km worst case is out of bounds
  # (i.e. nGenerations<0 or emergeDOY>5000)
  
  allowmissing!(df_10km, [:nGenerations_max, :nGenerations_median_max, :nGenerations_anomaly_median, :emergeDOY_min, :emergeDOY_median_min, :emergeDOY_anomaly_median])
  df_10km.nGenerations_max[df_10km.nGenerations_max.<0] .= 0.0
  df_10km.nGenerations_anomaly_median[abs.(df_10km.nGenerations_anomaly_median).>5000] .= missing
  df_10km.nGenerations_median_max[df_10km.nGenerations_median_max.<0] .= 0.0

  df_10km.emergeDOY_min[df_10km.emergeDOY_min.>5000] .= missing
  df_10km.emergeDOY_anomaly_median[abs.(df_10km.emergeDOY_anomaly_median).>5000] .= missing
  df_10km.emergeDOY_median_min[df_10km.emergeDOY_median_min.>5000] .= missing

  return df_10km

end




# ================ End of Function Definitions ======================
# ===================================================================


