# OPRAM_processing_functions.jl
# Functions for processing degree day models 
# once the basic results have been generated by OPRAM_main_program

# function doy_results(dates, years, speciesName, params)
# function extract_results(doy::Int32, result::DataFrame)
# function create_doy_results(dates::Vector{Date}, adult_emerge::DataFrame)
# function aggregate_to_hectad(result_1km::DataFrame, grid::DataFrame)

#
# Jon Yearsley (jon.yearsley@ucd.ie)
# 2nd June 2025
#
# ====================================================================



# =========================================================
# ============= Defne functions ===========================


# function doy_results(years, speciesName, params, paths)
#   # This function is deprecated. Use read_OPRAM_JLD2 instead (defined in OPRAM_io_functions.jl)
#   # Function to extract model results for specific days of year
#   # across multiple years
#   #
#   # Arguments:
#   #   dates              information about the spatial grid
#   #   years              results from the model on 1km grid
#   #   speciesName        name of the species
#   #   run_params         a tuple of runtime parameters
#   #  
#   #  Output:
#   #   a data frame with the following columns:
#   #       ID            unique ID for each spatial location
#   #       startDate     date when larval development begins
#   #       emergeDate    date of adult emergence
#   #       nGenerations  the number of generations within the year
#   #       
#   #       
#   ########################################################################


#   dVec = Vector{DataFrame}(undef, length(years))
#   for y in eachindex(years)
#     @info "Importing data for year $(years[y])"

#     # Find the relevant file name and import the corresponding jld2 file
#     inFile = filter(x -> occursin(r"^" * speciesName * "_" * params.country * "_" * string(years[y]) * "_1km.jld2", x),
#       readdir(joinpath(paths.outDir, speciesName)))

#     if length(inFile) > 1
#       @error "More than one input file found"
#     end
#     # Load data on emergence dates
#     emerge = load_object(joinpath(paths.outDir, speciesName, inFile[1]))



#     @info " ---- Generating output for specific starting dates"
#     # Starting dates for output in CSV files
#     # The first of every month
#     dates = [Date(years[y], m, 1) for m in 1:12]

#     # Create output for specific days of year
#     dVec[y] = create_doy_results(dates, emerge)

#     # Select columns to work with
#     select!(dVec[y], [:ID, :startDate, :emergeDOY, :nGenerations])
#   end

#   # Put all the model results data together into one Matrix
#   return reduce(vcat, dVec)
# end






# ------------------------------------------------------------------------------------------



function extract_results(doy::Int32, result::DataFrame)
  # Function to calculate number of generations per year, and first
  # day of adult emergence based on a starting development on doy
  #
  #  If development doesn't complete by the end of the simulation (usually 3 years)
  #  then the emergeDOY and nGenerations is set to missing
  #
  #  Arguments:
  #      doy         day of year when larval development begins
  #      result data frame containing the results from the model
  #  
  #  Output:
  #   a data frame with the following columns:
  #       ID            unique ID for each spatial location   
  #       startDOY      day of year to start development     
  #       nGenerations  the number of generations within the year
  #       emergeDOY     adult emergence day of year 
  #       east_idx      index for eastings of the unique spatial locations in result
  #       north_idx     index for northings of the unique spatial location in result
  ########################################################################

  # Find start and end indicies for each location
  # @time idx1 = [searchsortedfirst(result.ID, loc) for loc in unique(result.ID)]
  # @time idx2 = [searchsortedlast(result.ID, loc) for loc in unique(result.ID)]
  idx1 = indexin(unique(result.ID), result.ID)
  idx2 = vcat(idx1[2:end] .- 1, length(result.ID))


  # Create data frame to hold results
  out_res = DataFrame(ID=result.ID[idx1],
    startDOY=doy,
    nGenerations=0.0,      # Must be Float because it can be fractional 
    emergeDOY=Vector{Union{Missing,Int32}}(missing, length(idx1)))

  # # Add indices for eastings and northings
  # # These are used to identify the spatial location in the grid
  # # (these are not used in the model but are useful for plotting)
  # out_res.north_idx = mod.(out_res.ID, 1000)
  # out_res.east_idx = div.((out_res.ID .- out_res.north_idx), 1000)

  allowmissing!(out_res, :nGenerations)

  # Set up starting DOY for each location
  startDOY = zeros(Union{Missing,Int32}, length(idx1)) .+ doy  # Start DOY for each location
  first_pass = true                                            # True for the first generation

  # Set startDOY to zero for a location if no more generations can be completed in the year
  # when all startDOY are zero then stop
  while any(startDOY .> 0)
    # Find index of result output that corresponds to desired day of year (ie doy>=result.DOY)
    # this assumes results are ordered by DOY for each location
    idx3 = [searchsortedfirst(result.DOY[idx1[i]:idx2[i]], startDOY[i]) - 1 + idx1[i] for i in eachindex(idx1)]

    # Find out if end of current developmental generation is in the results (i.e. occurs before data on next location)
    # idx2[i] is the last index for the present location
    # idx2[i]+1 is the first index of the next location   = idx1[i+1]
    development_complete = startDOY .> 0 .&& idx2 .+ 1 .> idx3

    # Find out if development happens within the first year
    if (idx3[end] == nrow(result) + 1)
      # If final idx3 gives no developement (i.e. idx3[end] is nrow+1) then 
      # set its within_a_year to false
      within_a_year = result.emergeDOY[idx3[1:end-1]] .<= 365   # Is the generation complete 
      # within the year?
      push!(within_a_year, false)                      # Add a single false for the last index
    else
      # Work out all values of within_a_year
      # Is the generation complete within the year?
      within_a_year = result.emergeDOY[idx3] .<= 365
    end

    # Create booleans that will increment generation count
    full_generation = development_complete .& within_a_year
    partial_generation = development_complete .& .!within_a_year

    # Add on one full generation
    out_res.nGenerations[full_generation] .+= 1

    # Calculate end of year fraction of time towards next generation
    out_res.nGenerations[partial_generation] .+= (365 .- startDOY[partial_generation]) ./
                                                 (result.emergeDOY[idx3[partial_generation]] - startDOY[partial_generation])

    # If this is the first time through the loop, record the emergance day
    if first_pass
      # Only update adult emergence DOY if emergence is complete (but could take multiple years)   
      out_res.emergeDOY[development_complete] .= result.emergeDOY[idx3[development_complete]]
      first_pass = false
    end

    # Reset starting DOY to zero
    startDOY = zeros(Int32, length(idx1))

    # If a full generation completed within the year, update starting doy to be the
    # day after generation completed
    startDOY[full_generation] .= result.emergeDOY[idx3[full_generation]] .+ 1

    # Remove startDOY >= 365
    startDOY[startDOY.>=365] .= 0
  end

  # Set nGenerations to missing if no emergence occurs within the simulation
  out_res.nGenerations[ismissing.(out_res.emergeDOY)] .= missing

  return (out_res)
end





# ------------------------------------------------------------------------------------------




function create_doy_results(dates::Vector{Date}, adult_emerge::DataFrame, grid::DataFrame)
  # Function to calculate number of generations per year, and first
  # day of adult emergence for specific starting days of year.
  # If emergence date exceeds simulation timeframe then set to missing
  #
  #   dates           a vector of dates when larval development begins
  #   run_params      a tuple of runtime parameters
  #   adult_emerge    data frame containing the results from the model
  #   grid            a data frame containing the spatial grid
  #  
  #  Output:
  #   a data frame with the following columns:
  #       ID            unique ID for each spatial location  
  #       startDOY      starting DOY for larval development  
  #       startDate     starting date for larval development  
  #       nGenerations  number of generations in a year    
  #       emergeDOY     adult emergence day of year 
  #       emergeDate    adult emergence date 
  #       east_idx      index for eastings of the unique spatial locations in result
  #       north_idx     index for northings of the unique spatial location in result
  ########################################################################

  # Initialise dataframe for outputs
  out = DataFrame(ID=Int32[], 
                  startDOY=Int32[], 
                  startDate = Date[],
                  nGenerations=Vector{Union{Missing,Float64}}(missing, 0), 
                  emergeDOY=Vector{Union{Missing,Int32}}(missing, 0))


  # # Add indices for eastings and northings
  # # These are used to identify the spatial location in the grid
  # # (these are not used in the model but are useful for plotting)
  # out_res.north_idx = mod.(out_res.ID, 1000)
  # out_res.east_idx = div.((out_res.ID .- out_res.north_idx), 1000)


  for d in eachindex(dates)
    # Produce results for a specific DOY
    result = extract_results(convert(Int32, dayofyear(dates[d])), adult_emerge)

    # Add in a column with starting dates and emergence dates rather than DOY 
    # (dates handle leap years when dealing with starting dates specified using months)
    result.startDate .= dates[d]

    # Find spatial locations with no output and add them to the result as missing
    # (these are locations where no emergence occurs within the simulation time frame)
    missingIDs = setdiff(grid.ID, result.ID)
    if !isempty(missingIDs)
      append!(result, 
             DataFrame(ID=missingIDs, 
                startDOY=convert(Int32, dayofyear(dates[d])),
                startDate = dates[d],
                nGenerations=missing,
                emergeDOY=missing))
    end    


    # # Initialise column with missing values
    # result.emergeDate = Vector{Union{Missing,Date}}(missing, length(result.ID))

    # # Find results with a non-zero emergence DOY
    # idx = .!ismissing.(result.emergeDOY)
    # # Calculate date of emergence from day of year
    # result.emergeDate[idx] = Date(year(dates[d])) .+ Day.(result.emergeDOY[idx] .- 1)

    # Add these results to the other outputs
    append!(out, result)
  end

  return out
end




# ------------------------------------------------------------------------------------------




function dist_create_doy_results(dates::Vector{Date}, adult_emerge::DataFrame)
  # Function to calculate number of generations per year, and first
  # day of adult emergence for specific starting days of year.
  # If emergence date exceeds simulation timeframe then set to missing
  #
  #   dates           a vector of dates when larval development begins
  #   run_params      a tuple of runtime parameters
  #   adult_emerge    data frame containing the results from the model
  #  
  #  Output:
  #   a data frame with the following columns:
  #       ID            unique ID for each spatial location  
  #       startDOY      starting DOY for larval development  
  #       startDate     starting date for larval development  
  #       nGenerations  number of generations in a year    
  #       emergeDOY     adult emergence day of year 
  #       emergeDate    adult emergence date 
  #       east_idx      index for eastings of the unique spatial locations in result
  #       north_idx     index for northings of the unique spatial location in result
  ########################################################################

  out = DataFrame()    # Initialise dataframe for outputs


  for d in eachindex(dates)
    # Produce results for a specific DOY
    result = extract_results(convert(Int32, dayofyear(dates[d])), adult_emerge)

    # Add in a column with starting dates and emergence dates rather than DOY
    result.startDate .= dates[d]

    # Initialise column with missing values
    result.emergeDate = Vector{Union{Missing,Date}}(missing, length(result.ID))

    # Find results with a non-zero emergence DOY
    idx = .!ismissing.(result.emergeDOY)
    # Calculate date of emergence from day of year
    result.emergeDate[idx] = Date(year(dates[d])) .+ Day.(result.emergeDOY[idx] .- 1)

    # Add these results to the other outputs
    append!(out, result)
  end

  return out
end




# ------------------------------------------------------------------------------------------




function aggregate_to_hectad(result_1km::DataFrame, grid::DataFrame)
  # Function to take results on a 1km grid an aggregate them to a 10km grid
  #
  # Arguments:
  #   grid              information about the spatial grid
  #   result_1km        results from the model on 1km grid
  #  
  #  Output:
  #   a data frame with the following columns:
  #       hectad            unique hectad grid reference
  #       east              easting of bottom left of hectad
  #       north             northing of bottom left of hectad
  #       startDOY          starting DOY for larval development  
  #       startDate         starting date for larval development  
  #       nGenerations_max  maximum number of generations in a year in hectad
  #       emergeDOY_min     minimum adult emergence day of year in a hectad
  #       emergeDate_min    minimum adult emergence date in a hectad
  ########################################################################

  # Add bottom left eastings and northings of a hectad into result_1km
  eastList = sort(unique(grid.east))
  northList = sort(unique(grid.north))
  result_1km.east_hectad = convert.(Int32, floor.(eastList[result_1km.east_idx] ./ 1e4) .* 1e4)
  result_1km.north_hectad = convert.(Int32, floor.(northList[result_1km.north_idx] ./ 1e4) .* 1e4)

  # Group data frame by location and then starting DOY/Date 
  df_group = groupby(result_1km, [:east_hectad, :north_hectad, :startDOY, :startDate])

  # Calculate worst case results within each hectad for nGenerations and emergeDOY
  # for each starting DOY. 
  # These worst case scenarios are not affected by locations where no emergence occurred
  df_agg = combine(df_group,
    :nGenerations => (x -> quantile(x, 1.0)) => :nGenerations_max,
    :emergeDOY => (x -> quantile(x, 0.0)) => :emergeDOY_min)   # Max generations per hectad and minimum emergence DOY

  # Add in columns with start and emergence dates
  df_agg.emergeDate_min = Vector{Union{Missing,Date}}(missing, nrow(df_agg))
  idx = df_agg.emergeDOY_min .> 0
  df_agg.emergeDate_min[idx] .= Date.(year.(df_agg.startDate[idx])) .+ Day.(floor.(df_agg.emergeDOY_min[idx]))


  # Create a code that corresponds to hectad in the grid data frame
  h_idx = [findfirst(grid.hectad .== h) for h in unique(grid.hectad)]
  h_nGen_idx = [findfirst(df_agg.east_hectad[i] .== floor.(grid.east[h_idx] ./ 1e4) .* 1e4 .&& df_agg.north_hectad[i] .== floor.(grid.north[h_idx] ./ 1e4) .* 1e4) for i in 1:nrow(df_agg)]
  
  # Add hectad code into both data frames
  insertcols!(df_agg, 1, :hectad => grid.hectad[h_idx[h_nGen_idx]], after=false)
  

  # Return final dataframe
  return df_agg
end


# ================ End of Function Definitions ======================
# ===================================================================





